searchState.loadedDescShard("cassowary", 0, "This crate contains an implementation of the Cassowary …\nThe possible error conditions that <code>Solver::add_constraint</code> …\nThe possible error conditions that …\nThe specified strength was <code>REQUIRED</code>. This is illegal for …\nA constraint, consisting of an equation governed by an …\nThe constraint specified has already been added to the …\nThe specified variable is already marked as an edit …\n<code>==</code>\n<code>==</code>\nAn expression that can be the left hand or right hand side …\n<code>&gt;=</code>\n<code>&gt;=</code>\nThe solver entered an invalid state. If this occurs please …\nThe solver entered an invalid state. If this occurs please …\nThe solver entered an invalid state. If this occurs please …\nThe solver entered an invalid state. If this occurs please …\n<code>&lt;=</code>\n<code>&lt;=</code>\nThis is an intermediate type used in the syntactic sugar …\nThe possible relations that a constraint can specify.\nThe possible error conditions that …\nThe possible error conditions that …\nA constraint solver using the Cassowary algorithm. For …\nThe possible error conditions that <code>Solver::suggest_value</code> …\nA variable and a coefficient to multiply that variable by. …\nThe constraint specified was not already in the solver, so …\nThe specified variable was not an edit variable in the …\nThe specified variable was not an edit variable in the …\nThe constraint is required, but it is unsatisfiable in …\nIdentifies a variable for the constraint solver. Each new …\nThis is part of the syntactic sugar used for specifying …\nAdd a constraint to the solver.\nAdd an edit variable to the solver.\nThe expression of the left hand side of the constraint …\nFetches all changes to the values of variables since the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs an expression of the form <em>n</em>, where n is a …\nConstructs an expression from a single term. Forms an …\nGet the stored value for a variable.\nTest whether a constraint has been added to the solver.\nTest whether an edit variable has been added to the solver.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMutates this expression by multiplying it by minus one.\nConstruct a new solver.\nProduces a new unique variable for use in constraint …\nGeneral constructor. Each <code>Term</code> in <code>terms</code> is part of the sum …\nConstruct a new constraint from an expression, a …\nThe relational operator governing the constraint.\nRemove a constraint from the solver.\nRemove an edit variable from the solver.\nReset the solver to the empty starting condition.\nContains useful constants and functions for producing …\nThe strength of the constraint that the solver will use.\nSuggest a value for the given edit variable.\nClips a strength value to the legal range\nCreate a constraint as a linear combination of STRONG, …")